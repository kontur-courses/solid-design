*Какие связи должны быть между модулями и внутри модуля?*
- Сильные внутри модуля (компонент, который имеет зону ответствености) и слабые снаружи.

*Как вы понимаете "Слабая связность (low coupling) и сильное зацепление (high cohesion)"?*
С переводом этих слов есть нюансы:
  - Близкие к cohesion понятия - сплоченность (consistency), согласованность (coherence), слаженность
  - Близкие к coupling понятия - связь (relation), соединение (connection), сцепление
Разные части модуля должны соответствовать главной цели, главной ответственности модуля - это high cohesion.
Между модулями связи должны быть как можно слабже - это low coupling.

*Вот есть у меня большое приложение! И внутри много связией! Я утверждаю, что это high cohesion. Прав ли я?*

- Нет. Раз приложение большое, то правильно разбить его на меньшие модули.
  Удачное разбиение, когда модули не будут зависеть друг от друга, т.е. иметь слабую связность.

*Сильная связность это плохо, почему?*
- Любое изменение требований потребует значительных изменений в коде, ведь ответственность размазана. Такой код жесткий, а чтобы его исправить надо очень много думать.

*Что надо делать, если внутри модуля слабые связи?*
- Значит у модуля несколько ответственностей, поэтому его можно и нужно разбить.

*Чем хороши маленькие модули?*
- Маленькие модули удобны, ведь их легко понять, протестировать и собрать что-то новое

*Насколько надо мельчить?*
- Слишком сильное не стоит - станет неудобно!

*Чем хороша слоистая архитектура?*
- В классической трехслойной архитектуре (представление, бизнес-логика, хранение данных) можно поменять архитектуру хранения или представления независимо от других слоев
- Можно менять реализацию, можно переиспользовать слои в других местах, можно мокать

*Определите OCP? Что это означает на практике? Чем это хорошо?*

- Модуль открыт для расширения, но закрыт для модификации
- Если мы хотим добавить новую функциональность, то в идеале мы не правим существующий код.
- Минимальна вероятность ошибки

*Приведите пример расширяемых систем?*

- ОС с помощью Applications
- VisualStudio с помощью плагинов
- JsonSerializer - переопределение серилизаций

*Определите DIP?*

- Конкретика должна зависеть от абстракций, а не наоборот

*Приведите примеры абстракции?*

- Абстракции - это интерфейсы, классы с виртуальными методами, делегаты

*В чем практическая ценность DIP?*

- Абстракции можно подменять в тестах
- Повышается переиспользуемость, ведь зависимости можно подменять
